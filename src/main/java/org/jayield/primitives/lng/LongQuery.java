/*
 * Copyright (c) 2018, Fernando Miguel Carvalho, mcarvalho@cc.isel.ipl.pt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jayield.primitives.lng;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.LongSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalLong;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Function;
import java.util.function.LongBinaryOperator;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;
import java.util.function.LongPredicate;
import java.util.function.LongSupplier;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.function.LongUnaryOperator;
import java.util.function.ObjLongConsumer;
import java.util.function.Supplier;
import java.util.stream.LongStream;
import java.util.stream.StreamSupport;

import org.jayield.Query;
import org.jayield.TraversableFinishError;
import org.jayield.Yield;
import org.jayield.boxes.BoolBox;
import org.jayield.boxes.LongBox;
import org.jayield.primitives.dbl.DoubleAdvancer;
import org.jayield.primitives.dbl.DoubleQuery;
import org.jayield.primitives.intgr.IntAdvancer;
import org.jayield.primitives.intgr.IntQuery;
import org.jayield.primitives.lng.advs.LongAdvancerArray;
import org.jayield.primitives.lng.advs.LongAdvancerConcat;
import org.jayield.primitives.lng.advs.LongAdvancerDistinct;
import org.jayield.primitives.lng.advs.LongAdvancerDropWhile;
import org.jayield.primitives.lng.advs.LongAdvancerFilter;
import org.jayield.primitives.lng.advs.LongAdvancerFlatMap;
import org.jayield.primitives.lng.advs.LongAdvancerGenerate;
import org.jayield.primitives.lng.advs.LongAdvancerIterate;
import org.jayield.primitives.lng.advs.LongAdvancerLimit;
import org.jayield.primitives.lng.advs.LongAdvancerMap;
import org.jayield.primitives.lng.advs.LongAdvancerMapToObj;
import org.jayield.primitives.lng.advs.LongAdvancerPeek;
import org.jayield.primitives.lng.advs.LongAdvancerSkip;
import org.jayield.primitives.lng.advs.LongAdvancerStream;
import org.jayield.primitives.lng.advs.LongAdvancerTakeWhile;
import org.jayield.primitives.lng.advs.LongAdvancerThen;
import org.jayield.primitives.lng.advs.LongAdvancerZip;

/**
 * A sequence of primitive long-valued elements supporting sequential
 * operations. This is the long primitive specialization of Query.
 */
public class LongQuery {

    private final LongAdvancer adv;

    public LongQuery(LongAdvancer adv) {
        this.adv = adv;
    }

    /**
     * Returns a sequential ordered {@code LongQuery} with elements
     * from the provided {@link LongStream} data.
     */
    public static LongQuery fromStream(LongStream src) {
        return new LongQuery(new LongAdvancerStream(src));
    }

    /**
     * Returns an infinite sequential ordered {@code LongQuery} produced by iterative
     * application of a function {@code f} to an initial element {@code seed},
     * producing a {@code LongQuery} consisting of {@code seed}, {@code f(seed)},
     * {@code f(f(seed))}, etc.
     */
    public static LongQuery iterate(long seed, LongUnaryOperator f) {
        return new LongQuery(new LongAdvancerIterate(seed, f));
    }

    /**
     * Returns an infinite sequential unordered {@code LongQuery}
     * where each element is generated by the provided Supplier.
     */
    public static LongQuery generate(LongSupplier s) {
        return new LongQuery(new LongAdvancerGenerate(s));
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void forEach(LongYield yield) {
        this.traverse(yield);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void traverse(LongYield yield) {
        this.adv.traverse(yield);
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery} that match
     * the given predicate.
     */
    public LongQuery filter(LongPredicate p) {
        return new LongQuery(new LongAdvancerFilter(adv, p));
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of applying the given
     * LongUnaryOperator to the elements of this {@code LongQuery}.
     *
     * @param op
     *         LongUnaryOperator used to map the elements of this LongQuery
     */
    public LongQuery map(LongUnaryOperator op) {
        return new LongQuery(new LongAdvancerMap(adv, op));
    }

    /**
     * Returns a {@code Query} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongFunction used to map the elements of this LongQuery
     */
    public <U> Query<U> mapToObj(LongFunction<? extends U> function) {
        return new Query<>(new LongAdvancerMapToObj<>(adv, function), trav);
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of replacing each element of
     * this {@code LongQuery} with the contents of a mapped {@code LongQuery} produced by applying
     * the provided mapping function to each element.
     */
    public LongQuery flatMap(LongFunction<? extends LongQuery> function) {
        return new LongQuery(new LongAdvancerFlatMap(this, function));
    }

    /**
     * Returns a query consisting of the distinct elements (according to
     * {@link Object#equals(Object)}) of this query.
     */
    public LongQuery distinct() {
        return new LongQuery(new LongAdvancerDistinct(adv));
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery},
     * sorted according to the same logic as {@code Arrays.sort(long[] a)}.
     * <p>
     * This is a stateful intermediate operation.
     */
    public LongQuery sorted() {
        long[] state = this.toArray();
        Arrays.sort(state);
        return new LongQuery(new LongAdvancerArray(state));
    }

    /**
     * Returns an array containing the elements of this {@code LongQuery}.
     */
    public long[] toArray() {
        List<Long> list = toList();
        long[] result = new long[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    /**
     * Returns a List containing the elements of this {@code LongQuery}.
     */
    public List<Long> toList() {
        ArrayList<Long> result = new ArrayList<>();
        this.traverse(result::add);
        return result;
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code LongQuery}, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting {@code LongQuery}.
     */
    public LongQuery peek(LongConsumer action) {
        return new LongQuery(new LongAdvancerPeek(adv, action));
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this query, truncated
     * to be no longer than {@code n} in length.
     *
     * @param n
     *         maximum amount of elements to retrieve from this {@code LongQuery}
     */
    public LongQuery limit(int n) {
        return new LongQuery(new LongAdvancerLimit(this, n));
    }

    /**
     * Returns a {@code LongQuery} consisting of the remaining elements of this {@code LongQuery}
     * after discarding the first {@code n} elements of the {@code LongQuery}.
     *
     * @param n
     *         number of elements to discard
     */
    public LongQuery skip(int n) {
        return new LongQuery(new LongAdvancerSkip(adv, n));
    }

    /**
     * Returns an {@link OptionalLong} with the resulting reduction of the elements of this {@code LongQuery},
     * if a reduction can be made, using the provided accumulator.
     */
    public OptionalLong reduce(LongBinaryOperator accumulator) {
        if (this.hasNext()) {
            return OptionalLong.of(this.reduce(this.next(), accumulator));
        } else {
            return OptionalLong.empty();
        }
    }

    /**
     * Returns {@code true} if the iteration has more elements.
     * (In other words, returns {@code true} if {@link #next} would
     * return an element rather than throwing an exception.)
     */
    public final boolean hasNext() {
        return this.adv.hasNext();
    }

    /**
     * Returns the result of the reduction of the elements of this {@code LongQuery},
     * using the provided identity value and accumulator.
     */
    public long reduce(long identity, LongBinaryOperator accumulator) {
        LongBox result = new LongBox();
        result.setValue(identity);
        this.traverse(elem -> result.setValue(accumulator.applyAsLong(result.getValue(), elem)));
        return result.getValue();
    }

    /**
     * Returns the next element in the iteration.
     */
    public final long next() {
        return this.adv.nextLong();
    }

    /**
     * Returns the lowest long of this {@code LongQuery}
     */
    public OptionalLong min() {
        LongBox b = new LongBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e < b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalLong.of(b.getValue()) : OptionalLong.empty();
    }

    /**
     * Returns the highest long of this {@code LongQuery}
     */
    public OptionalLong max() {
        LongBox b = new LongBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e > b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalLong.of(b.getValue()) : OptionalLong.empty();
    }

    /**
     * Returns the count of elements in this {@code LongQuery}.
     */
    public final long count() {
        class Counter implements LongYield {
            long n = 0;

            @Override
            public void ret(long item) {
                ++n;
            }
        }
        Counter c = new Counter();
        this.traverse(c);
        return c.n;
    }

    /**
     * Returns an OptionalDouble describing the arithmetic mean of elements of this {@code LongQuery},
     * or an empty optional if this {@code LongQuery} is empty. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public OptionalDouble average() {
        long[] data = this.toArray();
        double count = data.length;
        if (count == 0) {
            return OptionalDouble.empty();
        }
        double sum = LongQuery.of(data).sum();
        return OptionalDouble.of(sum / count);
    }

    /**
     * Returns the sum of elements in this {@code LongQuery} .
     * <p>
     * This is a special case of a reduction.
     */
    public long sum() {
        return this.reduce(0, Long::sum);
    }

    /**
     * Returns a sequential ordered {@code LongQuery} whose elements
     * are the specified values in data parameter.
     */
    public static LongQuery of(long... data) {
        return new LongQuery(new LongAdvancerArray(data));
    }

    /**
     * Returns an LongSummaryStatistics describing various summary data about
     * the elements of this {@code LongQuery}. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public LongSummaryStatistics summaryStatistics() {
        return this.collect(LongSummaryStatistics::new, LongSummaryStatistics::accept);
    }

    /**
     * Performs a mutable reduction operation on the elements of this {@code LongQuery}.
     * A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList,
     * and elements are incorporated by updating the state of the result rather than by replacing the result.
     */
    public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator) {
        R result = supplier.get();
        this.traverse(elem -> accumulator.accept(result, elem));
        return result;
    }

    /**
     * Returns whether all elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean allMatch(LongPredicate p) {
        BoolBox succeed = new BoolBox(true);
        shortCircuit(item -> {
            if (!p.test(item)) {
                succeed.set(false);
                Yield.bye();
            }
        });
        return succeed.isTrue();
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or the traversal
     * exited normally through the invocation of yield.bye().
     */
    public final void shortCircuit(LongYield yield) {
        try {
            this.adv.traverse(yield);
        } catch (TraversableFinishError e) {
            /* Proceed */
        }
    }

    /**
     * Returns whether no elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean noneMatch(LongPredicate p) {
        return !this.anyMatch(p);
    }

    /**
     * Returns whether any elements of this {@code LongQuery} match the provided
     * {@link LongPredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code false} is returned and the predicate is not evaluated.
     *
     * @param p
     *         LongPredicate used to test elements of this {@code LongQuery}
     */
    public boolean anyMatch(LongPredicate p) {
        BoolBox found = new BoolBox();
        shortCircuit(item -> {
            if (p.test(item)) {
                found.set();
                Yield.bye();
            }
        });
        return found.isTrue();
    }

    /**
     * Returns an {@link OptionalLong} describing any element of this {@code LongQuery},
     * or an empty {@code OptionalLong} if this {@code LongQuery} is empty.
     */
    public OptionalLong findAny() {
        return this.findFirst();
    }

    /**
     * Returns an {@link OptionalLong} describing the first element of this {@code LongQuery},
     * or an empty {@code OptionalLong} if this {@code LongQuery} is empty.
     */
    public OptionalLong findFirst() {
        LongBox box = new LongBox();
        this.shortCircuit(item -> {
            box.turnPresent(item);
            Yield.bye();
        });
        return box.isPresent()
                ? OptionalLong.of(box.getValue())
                : OptionalLong.empty();
    }

    /**
     * Returns a {@code IntQuery} consisting of the elements of this {@code LongQuery},
     * converted to int.
     * <p>
     * This is an intermediate operation.
     */
    public IntQuery asIntQuery() {
        return this.mapToInt(i -> (int) i);
    }

    /**
     * Returns a {@code IntQuery} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongToIntFunction used to map the elements of this LongQuery
     */
    public IntQuery mapToInt(LongToIntFunction function) {
        return new IntQuery(IntAdvancer.from(adv, function));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code LongQuery},
     * converted to double.
     * <p>
     * This is an intermediate operation.
     */
    public DoubleQuery asDoubleQuery() {
        return this.mapToDouble(i -> i);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of applying the given
     * function to the elements of this {@code LongQuery}.
     *
     * @param function
     *         LongToDoubleFunction used to map the elements of this LongQuery
     */
    public DoubleQuery mapToDouble(LongToDoubleFunction function) {
        return new DoubleQuery(DoubleAdvancer.from(adv, function));
    }

    /**
     * Returns a Stream consisting of the elements of this {@code LongQuery},
     * each boxed to an Long.
     */
    public Query<Long> boxed() {
        return new Query<>(adv, trav);
    }

    public LongStream toStream() {
        Spliterator.OfLong iter = new Spliterators.AbstractLongSpliterator(Long.MAX_VALUE, Spliterator.ORDERED) {
            @Override
            public boolean tryAdvance(LongConsumer action) {
                if (!adv.hasNext()) {
                    return false;
                }
                action.accept(adv.next());
                return true;
            }

            @Override
            public void forEachRemaining(LongConsumer action) {
                adv.traverse(action::accept);
            }
        };
        return StreamSupport.longStream(iter, false);
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain longo a function.
     * That function {@code next} is applied to this {@code LongQuery} to produce a new
     * {@code LongTraverser} object that is encapsulated in the resulting {@code LongQuery}.
     */
    public final LongQuery then(Function<LongQuery, LongTraverser> next) {
        return new LongQuery(new LongAdvancerThen(this, next));
    }

    /**
     * Returns a {@code LongQuery} consisting of the longest prefix of elements taken from
     * this {@code LongQuery} that match the given predicate.
     */
    public final LongQuery takeWhile(LongPredicate predicate) {
        return new LongQuery(new LongAdvancerTakeWhile(this, predicate));
    }

    /**
     * Creates a concatenated {@code Query} in which the elements are
     * all the elements of this {@code Query} followed by all the
     * elements of the other {@code Query}.
     */
    public final LongQuery concat(LongQuery other) {
        return new LongQuery(new LongAdvancerConcat(this, other));
    }

    /**
     * Returns a {@code LongQuery} consisting of the remaining elements of this query
     * after discarding the first sequence of elements that match the given Predicate.
     */
    public final LongQuery dropWhile(LongPredicate predicate) {
        return new LongQuery(new LongAdvancerDropWhile(this, predicate));
    }

    /**
     * Applies a specified function to the corresponding elements of two
     * sequences, producing a sequence of the results.
     */
    public final LongQuery zip(LongQuery other, LongBinaryOperator zipper) {
        return new LongQuery(new LongAdvancerZip(this.adv, other.adv, zipper));
    }
}
