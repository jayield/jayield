/*
 * Copyright (c) 2018, Fernando Miguel Carvalho, mcarvalho@cc.isel.ipl.pt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jayield.primitives.dbl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.DoubleSummaryStatistics;
import java.util.List;
import java.util.OptionalDouble;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleConsumer;
import java.util.function.DoubleFunction;
import java.util.function.DoublePredicate;
import java.util.function.DoubleSupplier;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.Function;
import java.util.function.ObjDoubleConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.StreamSupport;

import org.jayield.Query;
import org.jayield.TraversableFinishError;
import org.jayield.Yield;
import org.jayield.boxes.BoolBox;
import org.jayield.boxes.DoubleBox;
import org.jayield.primitives.dbl.advs.DoubleAdvancerArray;
import org.jayield.primitives.dbl.advs.DoubleAdvancerConcat;
import org.jayield.primitives.dbl.advs.DoubleAdvancerDistinct;
import org.jayield.primitives.dbl.advs.DoubleAdvancerDropWhile;
import org.jayield.primitives.dbl.advs.DoubleAdvancerFilter;
import org.jayield.primitives.dbl.advs.DoubleAdvancerFlatMap;
import org.jayield.primitives.dbl.advs.DoubleAdvancerGenerate;
import org.jayield.primitives.dbl.advs.DoubleAdvancerIterate;
import org.jayield.primitives.dbl.advs.DoubleAdvancerLimit;
import org.jayield.primitives.dbl.advs.DoubleAdvancerMap;
import org.jayield.primitives.dbl.advs.DoubleAdvancerMapToObj;
import org.jayield.primitives.dbl.advs.DoubleAdvancerPeek;
import org.jayield.primitives.dbl.advs.DoubleAdvancerSkip;
import org.jayield.primitives.dbl.advs.DoubleAdvancerStream;
import org.jayield.primitives.dbl.advs.DoubleAdvancerTakeWhile;
import org.jayield.primitives.dbl.advs.DoubleAdvancerThen;
import org.jayield.primitives.dbl.advs.DoubleAdvancerZip;
import org.jayield.primitives.intgr.IntAdvancer;
import org.jayield.primitives.intgr.IntQuery;
import org.jayield.primitives.lng.LongAdvancer;
import org.jayield.primitives.lng.LongQuery;

/**
 * A sequence of primitive double-valued elements supporting sequential
 * operations. This is the double primitive specialization of Query.
 */
public class DoubleQuery {

    private final DoubleAdvancer adv;

    public DoubleQuery(DoubleAdvancer adv) {
        this.adv = adv;
    }

    /**
     * Returns a sequential ordered {@code DoubleQuery} with elements
     * from the provided {@link DoubleStream} data.
     */
    public static DoubleQuery fromStream(DoubleStream src) {
        return new DoubleQuery(new DoubleAdvancerStream(src));
    }

    /**
     * Returns an infinite sequential ordered {@code DoubleQuery} produced by iterative
     * application of a function {@code f} to an initial element {@code seed},
     * producing a {@code DoubleQuery} consisting of {@code seed}, {@code f(seed)},
     * {@code f(f(seed))}, etc.
     */
    public static DoubleQuery iterate(double seed, DoubleUnaryOperator f) {
        return new DoubleQuery(new DoubleAdvancerIterate(seed, f));
    }

    /**
     * Returns an infinite sequential unordered {@code DoubleQuery}
     * where each element is generated by the provided Supplier.
     */
    public static DoubleQuery generate(DoubleSupplier s) {
        return new DoubleQuery(new DoubleAdvancerGenerate(s));
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void forEach(DoubleYield yield) {
        this.traverse(yield);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void traverse(DoubleYield yield) {
        this.adv.traverse(yield);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery} that match
     * the given predicate.
     */
    public DoubleQuery filter(DoublePredicate p) {
        return new DoubleQuery(new DoubleAdvancerFilter(adv, p));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of applying the given
     * DoubleUnaryOperator to the elements of this {@code DoubleQuery}.
     *
     * @param op
     *         DoubleUnaryOperator used to map the elements of this DoubleQuery
     */
    public DoubleQuery map(DoubleUnaryOperator op) {
        return new DoubleQuery(new DoubleAdvancerMap(adv, op));
    }

    /**
     * Returns a {@code Query} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function
     *         DoubleFunction used to map the elements of this DoubleQuery
     */
    public <U> Query<U> mapToObj(DoubleFunction<? extends U> function) {
        return new Query<>(new DoubleAdvancerMapToObj<>(adv, function), trav);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of replacing each element of
     * this {@code DoubleQuery} with the contents of a mapped {@code DoubleQuery} produced by applying
     * the provided mapping function to each element.
     */
    public DoubleQuery flatMap(DoubleFunction<? extends DoubleQuery> function) {
        return new DoubleQuery(new DoubleAdvancerFlatMap(this, function));
    }

    /**
     * Returns a query consisting of the distinct elements (according to
     * {@link Object#equals(Object)}) of this query.
     */
    public DoubleQuery distinct() {
        return new DoubleQuery(new DoubleAdvancerDistinct(adv));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery},
     * sorted according to the same logic as {@code Arrays.sort(double[] a)}.
     * <p>
     * This is a stateful intermediate operation.
     */
    public DoubleQuery sorted() {
        double[] state = this.toArray();
        Arrays.sort(state);
        return new DoubleQuery(new DoubleAdvancerArray(state));
    }

    /**
     * Returns an array containing the elements of this {@code DoubleQuery}.
     */
    public double[] toArray() {
        List<Double> list = toList();
        double[] result = new double[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    /**
     * Returns a List containing the elements of this {@code DoubleQuery}.
     */
    public List<Double> toList() {
        ArrayList<Double> result = new ArrayList<>();
        this.traverse(result::add);
        return result;
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery}, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting {@code DoubleQuery}.
     */
    public DoubleQuery peek(DoubleConsumer action) {
        return new DoubleQuery(new DoubleAdvancerPeek(adv, action));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this query, truncated
     * to be no longer than {@code n} in length.
     *
     * @param n
     *         maximum amount of elements to retrieve from this {@code DoubleQuery}
     */
    public DoubleQuery limit(int n) {
        return new DoubleQuery(new DoubleAdvancerLimit(this, n));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the remaining elements of this {@code DoubleQuery}
     * after discarding the first {@code n} elements of the {@code DoubleQuery}.
     *
     * @param n
     *         number of elements to discard
     */
    public DoubleQuery skip(int n) {
        return new DoubleQuery(new DoubleAdvancerSkip(adv, n));
    }

    /**
     * Returns an {@link OptionalDouble} with the resulting reduction of the elements of this {@code DoubleQuery},
     * if a reduction can be made, using the provided accumulator.
     */
    public OptionalDouble reduce(DoubleBinaryOperator accumulator) {
        if (this.hasNext()) {
            return OptionalDouble.of(this.reduce(this.next(), accumulator));
        } else {
            return OptionalDouble.empty();
        }
    }

    /**
     * Returns {@code true} if the iteration has more elements.
     * (In other words, returns {@code true} if {@link #next} would
     * return an element rather than throwing an exception.)
     */
    public final boolean hasNext() {
        return this.adv.hasNext();
    }

    /**
     * Returns the result of the reduction of the elements of this {@code DoubleQuery},
     * using the provided identity value and accumulator.
     */
    public double reduce(double identity, DoubleBinaryOperator accumulator) {
        DoubleBox result = new DoubleBox();
        result.setValue(identity);
        this.traverse(elem -> result.setValue(accumulator.applyAsDouble(result.getValue(), elem)));
        return result.getValue();
    }

    /**
     * Returns the next element in the iteration.
     */
    public final double next() {
        return this.adv.nextDouble();
    }

    /**
     * Returns the lowest double of this {@code DoubleQuery}
     */
    public OptionalDouble min() {
        DoubleBox b = new DoubleBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e < b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalDouble.of(b.getValue()) : OptionalDouble.empty();
    }

    /**
     * Returns the highest double of this {@code DoubleQuery}
     */
    public OptionalDouble max() {
        DoubleBox b = new DoubleBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e > b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalDouble.of(b.getValue()) : OptionalDouble.empty();
    }

    /**
     * Returns the count of elements in this {@code DoubleQuery}.
     */
    public final long count() {
        class Counter implements DoubleYield {
            long n = 0;

            @Override
            public void ret(double item) {
                ++n;
            }
        }
        Counter c = new Counter();
        this.traverse(c);
        return c.n;
    }

    /**
     * Returns an OptionalDouble describing the arithmetic mean of elements of this {@code DoubleQuery},
     * or an empty optional if this {@code DoubleQuery} is empty. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public OptionalDouble average() {
        double[] data = this.toArray();
        double count = data.length;
        if (count == 0) {
            return OptionalDouble.empty();
        }
        double sum = DoubleQuery.of(data).sum();
        return OptionalDouble.of(sum / count);
    }

    /**
     * Returns the sum of elements in this {@code DoubleQuery} .
     * <p>
     * This is a special case of a reduction.
     */
    public double sum() {
        return this.reduce(0, Double::sum);
    }

    /**
     * Returns a sequential ordered {@code DoubleQuery} whose elements
     * are the specified values in data parameter.
     */
    public static DoubleQuery of(double... data) {
        return new DoubleQuery(new DoubleAdvancerArray(data));
    }

    /**
     * Returns an DoubleSummaryStatistics describing various summary data about
     * the elements of this {@code DoubleQuery}. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public DoubleSummaryStatistics summaryStatistics() {
        return this.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept);
    }

    /**
     * Performs a mutable reduction operation on the elements of this {@code DoubleQuery}.
     * A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList,
     * and elements are incorporated by updating the state of the result rather than by replacing the result.
     */
    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator) {
        R result = supplier.get();
        this.traverse(elem -> accumulator.accept(result, elem));
        return result;
    }

    /**
     * Returns whether all elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean allMatch(DoublePredicate p) {
        BoolBox succeed = new BoolBox(true);
        shortCircuit(item -> {
            if (!p.test(item)) {
                succeed.set(false);
                Yield.bye();
            }
        });
        return succeed.isTrue();
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or the traversal
     * exited normally through the invocation of yield.bye().
     */
    public final void shortCircuit(DoubleYield yield) {
        try {
            this.adv.traverse(yield);
        } catch (TraversableFinishError e) {
            /* Proceed */
        }
    }

    /**
     * Returns whether no elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean noneMatch(DoublePredicate p) {
        return !this.anyMatch(p);
    }

    /**
     * Returns whether any elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code false} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean anyMatch(DoublePredicate p) {
        BoolBox found = new BoolBox();
        shortCircuit(item -> {
            if (p.test(item)) {
                found.set();
                Yield.bye();
            }
        });
        return found.isTrue();
    }

    /**
     * Returns an {@link OptionalDouble} describing any element of this {@code DoubleQuery},
     * or an empty {@code OptionalDouble} if this {@code DoubleQuery} is empty.
     */
    public OptionalDouble findAny() {
        return this.findFirst();
    }

    /**
     * Returns an {@link OptionalDouble} describing the first element of this {@code DoubleQuery},
     * or an empty {@code OptionalDouble} if this {@code DoubleQuery} is empty.
     */
    public OptionalDouble findFirst() {
        DoubleBox box = new DoubleBox();
        this.shortCircuit(item -> {
            box.turnPresent(item);
            Yield.bye();
        });
        return box.isPresent()
                ? OptionalDouble.of(box.getValue())
                : OptionalDouble.empty();
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code DoubleQuery},
     * converted to long. It's equivalent to calling Math.round on every element
     * <p>
     * This is an intermediate operation.
     */
    public LongQuery asLongQuery() {
        return this.mapToLong(Math::round);
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function DoubleToLongFunction used to map the elements of this DoubleQuery
     */
    public LongQuery mapToLong(DoubleToLongFunction function) {
        return new LongQuery(LongAdvancer.from(adv, function));
    }

    /**
     * Returns a {@code IntQuery} consisting of the elements of this {@code DoubleQuery},
     * converted to int. It's equivalent to calling Math.round on every element
     * <p>
     * This is an intermediate operation.
     */
    public IntQuery asIntQuery() {
        return this.mapToInt(v -> (int) Math.round(v));
    }

    /**
     * Returns a {@code IntQuery} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function DoubleToIntFunction used to map the elements of this DoubleQuery
     */
    public IntQuery mapToInt(DoubleToIntFunction function) {
        return new IntQuery(IntAdvancer.from(adv, function));
    }

    /**
     * Returns a Stream consisting of the elements of this {@code DoubleQuery},
     * each boxed to an Double.
     */
    public Query<Double> boxed() {
        return new Query<>(adv, trav);
    }

    public DoubleStream toStream() {
        Spliterator.OfDouble iter = new Spliterators.AbstractDoubleSpliterator(Long.MAX_VALUE, Spliterator.ORDERED) {
            @Override
            public boolean tryAdvance(DoubleConsumer action) {
                if (!adv.hasNext()) {
                    return false;
                }
                action.accept(adv.next());
                return true;
            }

            @Override
            public void forEachRemaining(DoubleConsumer action) {
                adv.traverse(action::accept);
            }
        };
        return StreamSupport.doubleStream(iter, false);
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain into a function.
     * That function {@code next} is applied to this {@code DoubleQuery} to produce a new
     * {@code DoubleTraverser} object that is encapsulated in the resulting {@code DoubleQuery}.
     */
    public final DoubleQuery then(Function<DoubleQuery, DoubleTraverser> next) {
        return new DoubleQuery(new DoubleAdvancerThen(this, next));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the longest prefix of elements taken from
     * this {@code DoubleQuery} that match the given predicate.
     */
    public final DoubleQuery takeWhile(DoublePredicate predicate) {
        return new DoubleQuery(new DoubleAdvancerTakeWhile(this, predicate));
    }

    /**
     * Creates a concatenated {@code Query} in which the elements are
     * all the elements of this {@code Query} followed by all the
     * elements of the other {@code Query}.
     */
    public final DoubleQuery concat(DoubleQuery other) {
        return new DoubleQuery(new DoubleAdvancerConcat(this, other));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the remaining elements of this query
     * after discarding the first sequence of elements that match the given Predicate.
     */
    public final DoubleQuery dropWhile(DoublePredicate predicate) {
        return new DoubleQuery(new DoubleAdvancerDropWhile(this, predicate));
    }

    /**
     * Applies a specified function to the corresponding elements of two
     * sequences, producing a sequence of the results.
     */
    public final DoubleQuery zip(DoubleQuery other, DoubleBinaryOperator zipper) {
        return new DoubleQuery(new DoubleAdvancerZip(this.adv, other.adv, zipper));
    }
}
