/*
 * Copyright (c) 2018, Fernando Miguel Carvalho, mcarvalho@cc.isel.ipl.pt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jayield.primitives.dbl;

import org.jayield.Query;
import org.jayield.TraversableFinishError;
import org.jayield.Yield;
import org.jayield.boxes.BoolBox;
import org.jayield.boxes.DoubleBox;
import org.jayield.primitives.dbl.ops.FromDoubleArray;
import org.jayield.primitives.dbl.ops.DoubleConcat;
import org.jayield.primitives.dbl.ops.DoubleDistinct;
import org.jayield.primitives.dbl.ops.DoubleDropWhile;
import org.jayield.primitives.dbl.ops.DoubleFilter;
import org.jayield.primitives.dbl.ops.DoubleFlatMap;
import org.jayield.primitives.dbl.ops.DoubleGenerate;
import org.jayield.primitives.dbl.ops.DoubleIterate;
import org.jayield.primitives.dbl.ops.DoubleLimit;
import org.jayield.primitives.dbl.ops.DoubleMapping;
import org.jayield.primitives.dbl.ops.DoubleMapToObj;
import org.jayield.primitives.dbl.ops.DoublePeek;
import org.jayield.primitives.dbl.ops.DoubleSkip;
import org.jayield.primitives.dbl.ops.FromDoubleStream;
import org.jayield.primitives.dbl.ops.DoubleTakeWhile;
import org.jayield.primitives.dbl.ops.DoubleZip;
import org.jayield.primitives.intgr.IntAdvancer;
import org.jayield.primitives.intgr.IntQuery;
import org.jayield.primitives.intgr.IntTraverser;
import org.jayield.primitives.lng.LongAdvancer;
import org.jayield.primitives.lng.LongQuery;
import org.jayield.primitives.lng.LongTraverser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.DoubleSummaryStatistics;
import java.util.List;
import java.util.OptionalDouble;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleConsumer;
import java.util.function.DoubleFunction;
import java.util.function.DoublePredicate;
import java.util.function.DoubleSupplier;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.Function;
import java.util.function.ObjDoubleConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.StreamSupport;

/**
 * A sequence of primitive double-valued elements supporting sequential
 * operations. This is the double primitive specialization of Query.
 */
public class DoubleQuery {

    private final DoubleAdvancer adv;
    private final DoubleTraverser trav;

    public DoubleQuery(DoubleAdvancer adv, DoubleTraverser trav) {
        this.adv = adv;
        this.trav = trav;
    }

    /**
     * Returns a sequential ordered {@code DoubleQuery} with elements
     * from the provided {@link DoubleStream} data.
     */
    public static DoubleQuery fromStream(DoubleStream src) {
        FromDoubleStream strm = new FromDoubleStream(src);
        return new DoubleQuery(strm, strm);
    }

    /**
     * Returns an infinite sequential ordered {@code DoubleQuery} produced by iterative
     * application of a function {@code f} to an initial element {@code seed},
     * producing a {@code DoubleQuery} consisting of {@code seed}, {@code f(seed)},
     * {@code f(f(seed))}, etc.
     */
    public static DoubleQuery iterate(double seed, DoubleUnaryOperator f) {
        DoubleIterate iter = new DoubleIterate(seed, f);
        return new DoubleQuery(iter, iter);
    }

    /**
     * Returns an infinite sequential unordered {@code DoubleQuery}
     * where each element is generated by the provided Supplier.
     */
    public static DoubleQuery generate(DoubleSupplier s) {
        DoubleGenerate gen = new DoubleGenerate(s);
        return new DoubleQuery(gen, gen);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void forEach(DoubleYield yield) {
        this.traverse(yield);
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or an
     * exception is thrown.
     */
    public final void traverse(DoubleYield yield) {
        this.trav.traverse(yield);
    }
    /**
     * If a remaining element exists, yields that element through
     * the given action.
     */
    public boolean tryAdvance(DoubleYield action) {
        return this.adv.tryAdvance(action);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery} that match
     * the given predicate.
     */
    public DoubleQuery filter(DoublePredicate p) {
        DoubleFilter filter = new DoubleFilter(this, p);
        return new DoubleQuery(filter, filter);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of applying the given
     * DoubleUnaryOperator to the elements of this {@code DoubleQuery}.
     *
     * @param op
     *         DoubleUnaryOperator used to map the elements of this DoubleQuery
     */
    public DoubleQuery map(DoubleUnaryOperator op) {
        DoubleMapping map = new DoubleMapping(this, op);
        return new DoubleQuery(map, map);
    }

    /**
     * Returns a {@code Query} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function
     *         DoubleFunction used to map the elements of this DoubleQuery
     */
    public <U> Query<U> mapToObj(DoubleFunction<? extends U> function) {
        DoubleMapToObj<U> map = new DoubleMapToObj<>(this, function);
        return new Query<>(map, map);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the results of replacing each element of
     * this {@code DoubleQuery} with the contents of a mapped {@code DoubleQuery} produced by applying
     * the provided mapping function to each element.
     */
    public DoubleQuery flatMap(DoubleFunction<? extends DoubleQuery> function) {
        DoubleFlatMap map = new DoubleFlatMap(this, function);
        return new DoubleQuery(map, map);
    }

    /**
     * Returns a query consisting of the distinct elements (according to
     * {@link Object#equals(Object)}) of this query.
     */
    public DoubleQuery distinct() {
        DoubleDistinct dist = new DoubleDistinct(this);
        return new DoubleQuery(dist, dist);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery},
     * sorted according to the same logic as {@code Arrays.sort(double[] a)}.
     * <p>
     * This is a stateful intermediate operation.
     */
    public DoubleQuery sorted() {
        double[] state = this.toArray();
        Arrays.sort(state);
        FromDoubleArray arr = new FromDoubleArray(state);
        return new DoubleQuery(arr, arr);
    }

    /**
     * Returns an array containing the elements of this {@code DoubleQuery}.
     */
    public double[] toArray() {
        List<Double> list = toList();
        double[] result = new double[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }

    /**
     * Returns a List containing the elements of this {@code DoubleQuery}.
     */
    public List<Double> toList() {
        ArrayList<Double> result = new ArrayList<>();
        this.traverse(result::add);
        return result;
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this {@code DoubleQuery}, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting {@code DoubleQuery}.
     */
    public DoubleQuery peek(DoubleConsumer action) {
        DoublePeek peek = new DoublePeek(this, action);
        return new DoubleQuery(peek, peek);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the elements of this query, truncated
     * to be no longer than {@code n} in length.
     *
     * @param n
     *         maximum amount of elements to retrieve from this {@code DoubleQuery}
     */
    public DoubleQuery limit(int n) {
        DoubleLimit lim = new DoubleLimit(this, n);
        return new DoubleQuery(lim, lim);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the remaining elements of this {@code DoubleQuery}
     * after discarding the first {@code n} elements of the {@code DoubleQuery}.
     *
     * @param n
     *         number of elements to discard
     */
    public DoubleQuery skip(int n) {
        DoubleSkip skip = new DoubleSkip(this, n);
        return new DoubleQuery(skip, skip);
    }

    /**
     * Returns an {@link OptionalDouble} with the resulting reduction of the elements of this {@code DoubleQuery},
     * if a reduction can be made, using the provided accumulator.
     */
    public OptionalDouble reduce(DoubleBinaryOperator accumulator) {
        DoubleBox box = new DoubleBox();
        if(this.tryAdvance(box::setValue)) {
            return OptionalDouble.of(this.reduce(box.getValue(), accumulator));
        } else {
            return OptionalDouble.empty();
        }
    }
    /**
     * Returns the result of the reduction of the elements of this {@code DoubleQuery},
     * using the provided identity value and accumulator.
     */
    public double reduce(double identity, DoubleBinaryOperator accumulator) {
        class BoxAccumulator extends DoubleBox implements DoubleYield {
            public BoxAccumulator(double identity) {
                super(identity);
            }
            @Override
            public void ret(double item) {
                this.value = accumulator.applyAsDouble(value, item);
            }
        }
        BoxAccumulator box = new BoxAccumulator(identity);
        this.traverse(box);
        return box.getValue();
    }

   /**
     * Returns the lowest double of this {@code DoubleQuery}
     */
    public OptionalDouble min() {
        DoubleBox b = new DoubleBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e < b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalDouble.of(b.getValue()) : OptionalDouble.empty();
    }

    /**
     * Returns the highest double of this {@code DoubleQuery}
     */
    public OptionalDouble max() {
        DoubleBox b = new DoubleBox();
        this.traverse(e -> {
            if (!b.isPresent()) {
                b.turnPresent(e);
            } else if (e > b.getValue()) {
                b.setValue(e);
            }
        });
        return b.isPresent() ? OptionalDouble.of(b.getValue()) : OptionalDouble.empty();
    }

    /**
     * Returns the count of elements in this {@code DoubleQuery}.
     */
    public final long count() {
        class Counter implements DoubleYield {
            long n = 0;

            @Override
            public void ret(double item) {
                ++n;
            }
        }
        Counter c = new Counter();
        this.traverse(c);
        return c.n;
    }

    /**
     * Returns an OptionalDouble describing the arithmetic mean of elements of this {@code DoubleQuery},
     * or an empty optional if this {@code DoubleQuery} is empty. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public OptionalDouble average() {
        double[] data = this.toArray();
        double count = data.length;
        if (count == 0) {
            return OptionalDouble.empty();
        }
        double sum = DoubleQuery.of(data).sum();
        return OptionalDouble.of(sum / count);
    }

    /**
     * Returns the sum of elements in this {@code DoubleQuery} .
     * <p>
     * This is a special case of a reduction.
     */
    public double sum() {
        return this.reduce(0, Double::sum);
    }

    /**
     * Returns a sequential ordered {@code DoubleQuery} whose elements
     * are the specified values in data parameter.
     */
    public static DoubleQuery of(double... data) {
        FromDoubleArray arr = new FromDoubleArray(data);
        return new DoubleQuery(arr, arr);
    }

    /**
     * Returns an DoubleSummaryStatistics describing various summary data about
     * the elements of this {@code DoubleQuery}. This is a special case of a reduction.
     * <p>
     * This is a terminal operation.
     */
    public DoubleSummaryStatistics summaryStatistics() {
        return this.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept);
    }

    /**
     * Performs a mutable reduction operation on the elements of this {@code DoubleQuery}.
     * A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList,
     * and elements are incorporated by updating the state of the result rather than by replacing the result.
     */
    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator) {
        R result = supplier.get();
        this.traverse(elem -> accumulator.accept(result, elem));
        return result;
    }

    /**
     * Returns whether all elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean allMatch(DoublePredicate p) {
        BoolBox succeed = new BoolBox(true);
        shortCircuit(item -> {
            if (!p.test(item)) {
                succeed.set(false);
                Yield.bye();
            }
        });
        return succeed.isTrue();
    }

    /**
     * Yields elements sequentially in the current thread,
     * until all elements have been processed or the traversal
     * exited normally through the invocation of yield.bye().
     */
    public final void shortCircuit(DoubleYield yield) {
        try {
            this.trav.traverse(yield);
        } catch (TraversableFinishError e) {
            /* Proceed */
        }
    }

    /**
     * Returns whether no elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code true} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean noneMatch(DoublePredicate p) {
        return !this.anyMatch(p);
    }

    /**
     * Returns whether any elements of this {@code DoubleQuery} match the provided
     * {@link DoublePredicate}.  May not evaluate the predicate on all elements if not
     * necessary for determining the result.  If the query is empty then
     * {@code false} is returned and the predicate is not evaluated.
     *
     * @param p
     *         DoublePredicate used to test elements of this {@code DoubleQuery}
     */
    public boolean anyMatch(DoublePredicate p) {
        BoolBox found = new BoolBox();
        shortCircuit(item -> {
            if (p.test(item)) {
                found.set();
                Yield.bye();
            }
        });
        return found.isTrue();
    }

    /**
     * Returns an {@link OptionalDouble} describing any element of this {@code DoubleQuery},
     * or an empty {@code OptionalDouble} if this {@code DoubleQuery} is empty.
     */
    public OptionalDouble findAny() {
        return this.findFirst();
    }

    /**
     * Returns an {@link OptionalDouble} describing the first element of this {@code DoubleQuery},
     * or an empty {@code OptionalDouble} if this {@code DoubleQuery} is empty.
     */
    public OptionalDouble findFirst() {
        DoubleBox box = new DoubleBox();
        this.tryAdvance(box::turnPresent);
        return box.isPresent()
                ? OptionalDouble.of(box.getValue())
                : OptionalDouble.empty();
    }

    /**
     * Returns a {@code LongQuery} consisting of the elements of this {@code DoubleQuery},
     * converted to long. It's equivalent to calling Math.round on every element
     * <p>
     * This is an intermediate operation.
     */
    public LongQuery asLongQuery() {
        return this.mapToLong(Math::round);
    }

    /**
     * Returns a {@code LongQuery} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function DoubleToLongFunction used to map the elements of this DoubleQuery
     */
    public LongQuery mapToLong(DoubleToLongFunction function) {
        return new LongQuery(LongAdvancer.from(adv, function), LongTraverser.from(trav, function));
    }

    /**
     * Returns a {@code IntQuery} consisting of the elements of this {@code DoubleQuery},
     * converted to int. It's equivalent to calling Math.round on every element
     * <p>
     * This is an intermediate operation.
     */
    public IntQuery asIntQuery() {
        return this.mapToInt(v -> (int) Math.round(v));
    }

    /**
     * Returns a {@code IntQuery} consisting of the results of applying the given
     * function to the elements of this {@code DoubleQuery}.
     *
     * @param function DoubleToIntFunction used to map the elements of this DoubleQuery
     */
    public IntQuery mapToInt(DoubleToIntFunction function) {
        return new IntQuery(IntAdvancer.from(adv, function), IntTraverser.from(trav, function));
    }

    /**
     * Returns a Stream consisting of the elements of this {@code DoubleQuery},
     * each boxed to an Double.
     */
    public Query<Double> boxed() {
        return new Query<>(adv, trav);
    }

    public DoubleStream toStream() {
        Spliterator.OfDouble iter = new Spliterators.AbstractDoubleSpliterator(Long.MAX_VALUE, Spliterator.ORDERED) {
            @Override
            public boolean tryAdvance(DoubleConsumer action) {
                return adv.tryAdvance(action::accept);
            }

            @Override
            public void forEachRemaining(DoubleConsumer action) {
                trav.traverse(action::accept);
            }
        };
        return StreamSupport.doubleStream(iter, false);
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain into a function.
     * That function {@code next} is applied to this {@code DoubleQuery} to produce a new
     * {@code DoubleTraverser} object that is encapsulated in the resulting {@code DoubleQuery}.
     * On the other hand, the {@code nextAdv} is applied to this query to produce a new
     * {@code DoubleAdvancer} object that is encapsulated in the resulting query.
     */
    public final DoubleQuery then(
        Function<DoubleQuery,
        DoubleAdvancer> nextAdv,
        Function<DoubleQuery, DoubleTraverser> next)
    {
        return new DoubleQuery(nextAdv.apply(this), next.apply(this));
    }

    /**
     * The {@code then} operator lets you encapsulate a piece of an operator
     * chain into a function.
     * That function {@code next} is applied to this {@code DoubleQuery} to produce a new
     * {@code DoubleTraverser} object that is encapsulated in the resulting {@code DoubleQuery}.
     */
    public final DoubleQuery then(Function<DoubleQuery, DoubleTraverser> next) {
        DoubleAdvancer nextAdv = item -> { throw new UnsupportedOperationException(
            "Missing tryAdvance() implementation! Use the overloaded then() providing both Advancer and Traverser!");
        };
        return new DoubleQuery(nextAdv, next.apply(this));
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the longest prefix of elements taken from
     * this {@code DoubleQuery} that match the given predicate.
     */
    public final DoubleQuery takeWhile(DoublePredicate predicate) {
        DoubleTakeWhile take = new DoubleTakeWhile(this, predicate);
        return new DoubleQuery(take, take);
    }

    /**
     * Creates a concatenated {@code Query} in which the elements are
     * all the elements of this {@code Query} followed by all the
     * elements of the other {@code Query}.
     */
    public final DoubleQuery concat(DoubleQuery other) {
        DoubleConcat cat = new DoubleConcat(this, other);
        return new DoubleQuery(cat, cat);
    }

    /**
     * Returns a {@code DoubleQuery} consisting of the remaining elements of this query
     * after discarding the first sequence of elements that match the given Predicate.
     */
    public final DoubleQuery dropWhile(DoublePredicate predicate) {
        DoubleDropWhile drop = new DoubleDropWhile(this, predicate);
        return new DoubleQuery(drop, drop);
    }

    /**
     * Applies a specified function to the corresponding elements of two
     * sequences, producing a sequence of the results.
     */
    public final DoubleQuery zip(DoubleQuery other, DoubleBinaryOperator zipper) {
        DoubleZip zip = new DoubleZip(this, other, zipper);
        return new DoubleQuery(zip, zip);
    }
}
